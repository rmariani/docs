---
navhome: /docs/
---


# 1b: tree addressing

Check out the Nock [explanation](docs/nock/explanation/) for more
information on the tree-addressing system.

### `++cap`

Tree head

Tests whether the tree address `a` is in the head or tail of a noun. Produces
the constant atom `%2` if it is within the head (subtree `+2`), or the constant
atom `%3` if it is within the tail (subtree `+3`).

In the Urbit binary-tree system, a parent at address `n` will always have its
children at address `2n` and address `2n+1`.


Accepts
-------

`a` is an atom.

Produces
--------

A constant atom.

Source
------

        ++  cap                                                 ::  tree head
          ~/  %cap
          |=  a=@
          ^-  ?($2 $3)
          ?-  a
            $2        %2
            $3        %3
            ?(%0 %1)  !!
            *         $(a (div a 2))
          ==
        ::

Examples
--------

    > (cap 4)
    %2

    > (cap 6)
    %3

    > (cap (add 10 9))
    %2

    > (cap 1)                                    ::axis '0' is in neither the head nor the tail
    ! exit

    > (cap 0x40))                                ::0x1a is of the hexadecimal soft atom type (@ux)
    %2
    > `@`0x40
    64                           

    > (cap 'a')                                  ::'a' is of the cord (text) soft atom type (@t)
    %3
    > `@`'a'
    97                                        


***
### `++mas`

Address within head/tail?

Computes the tree address of atom `a` within either the head (`+2`) or tail
(`+3`) of a noun. That is, the head or tail of the noun -- whichever `a` lies
within -- is made a whole tree in its own right. You can think of it as
everything in the subtree being moved up a tier, and `a` assuming its new values
with respect to that.

Take this representation of a binary tree:

            1
          /   \
         /     \
        2       3
       / \      /\
      4   5    6  7
     /\   /\  /\  /\
      (continues...)

Using `(mas 7)` will return `3`, because address `+3` is the new position that
`+7` now occupies. Read the following new tree created with `(mas 7)` that has
the old addresses displayed in `()`.

            1(3)
           /    \
          2       3
         (6)     (7)
        / \       /\
       /   \     /  \
      4     5   6    7
     (12) (13) (14) (15)
    / \    / \ / \   / \
       (continues...)

Notice how the old values in the head (subtree `+2`) were not considered in this
case, because `+7` is within the tail (subtree `+3`).

Accepts
-------

`a` is an atom.

Produces
--------

An atom.

Source
------

        ++  mas                                                 ::  tree body
          ~/  %mas
          |=  a=@
          ^-  @
          ?-  a
            1   !!
            2   1
            3   1
            *   (add (mod a 2) (mul $(a (div a 2)) 2))
          ==
        ::

Examples
--------

    > (mas 3)
    1

    > (mas 4)
    2

    > (mas 5)
    3

    > (mas 6)
    2

    > (mas 7)
    3

    > (mas 11)
    7

    > (mas (mas 11))
    3

    > (mas 'p')
    47
    > `@`'p'                                     ::`p` is of the cord (text) soft atom type (@t)
    111

    > (mas 0)                                              
    ! exit                                       ::address `0` is in neither the head nor the tail

    > (mas 1)
    ! exit                                       ::address `1` is in neither the head nor the tail



***
### `++peg`

Address within address

Computes the absolute address of relative address `b` within the subtree `a`.

In other words, the subtree at address `a` is treated as a tree in its own right
(starting with root `+1`, head `+2`, and tail `+3`). Relative location `b` is
found within `a`, and then its absolute location, within the greater tree,
is returned.  

Running `(peg 3 4)`, for example, will return `12`. Looking at a tree diagram
makes it easy to see why.

                 1
              /     \
             /       \
            /         \
           2           3         <- here is the subtree `+3`
          / \         / \
         /   \       /   \
        4     5     6     7
       / \   / \   / \   / \
      8  9  10 11 12 13 14  15
     /\  /\ /\ /\ /\ /\ /\  /\
        (continues...)


When we only consider subtree at address `+3`, it has relative addresses that
are structured in the same way as its own parent tree's absolute addresses. The
absolute addresses are given in parentheses. Notice how relative address
`+4` is at the same position as absolute address `+12`.

            1(3)
           /    \
          2       3
         (6)     (7)
        / \       /\
       /   \     /  \
      4     5   6    7
    (12) (13) (14)  (15)
    / \    / \ / \   / \
     (continues...)


Accepts
-------

`a` is an atom.

`b` is an atom.

Produces
--------

An atom.

Source
------

    ++  peg                                                 ::  tree connect
      ~/  %peg
      |=  [a=@ b=@]                                         ::  creates a gate
      ?<  =(0 a)                                            ::  branches if there is no equality
      ^-  @                                                 ::  casts to type @
      ?-  b                                                 
        $1  a
        $2  (mul a 2)
        $3  +((mul a 2))
        *   (add (mod b 2) (mul $(b (div b 2)) 2))
      ==

Examples
--------

    > (peg 4 1)
    4

    > (peg 4 2)
    8

    > (peg 8 45)
    269

    > (peg 4 2)

    > (peg 5 'a')                               ::`a` is of the cord (text) soft atom type (@t)
    353
    > `@`'a'
    97

    > (peg 0x8 0x2d)                           ::`0x8` and `0x2d` are of the hexadecimal soft atom type (@ux)
    269
    > `@`0x8
    8
    > `@`0x2d




***
